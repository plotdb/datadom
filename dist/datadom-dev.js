// Generated by LiveScript 1.6.0
(function(){
  var json0, asc, wrap, serialize, deserialize, locate, main;
  if ((typeof module != 'undefined' && module !== null) && (typeof require != 'undefined' && require !== null)) {
    json0 = require('@plotdb/json0');
  }
  asc = function(n, node){
    if (Array.isArray(n.attr)) {
      n.attr.filter(function(it){
        return it && it[0];
      }).map(function(p){
        return node.setAttribute(p[0], p[1]);
      });
    }
    if (Array.isArray(n.style)) {
      n.style.filter(function(it){
        return it && it[0];
      }).map(function(p){
        return node.style[p[0]] = p[1];
      });
    }
    if (Array.isArray(n.cls)) {
      return node.classList.add.apply(node.classList, n.cls.filter(function(it){
        return it;
      }));
    }
  };
  /**
   * convert a DOM Node into JSON.
   * @param {Element} n - DOM node.
   * @return {json} a json object containing information of the input DOM Node.
   */
  wrap = function(n, plugins, win){
    var name, style, i, attr, v, cls, node, ref$, ref1$;
    win == null && (win = window);
    name = n.nodeName.toLowerCase();
    if (name === '#text') {
      return {
        type: 'text',
        value: n.nodeValue
      };
    }
    if (name === '#comment') {
      return {
        type: 'comment',
        value: n.nodeValue
      };
    }
    if (name === '#document-fragment') {
      return {
        type: 'document-fragment'
      };
    }
    style = n.style
      ? (function(){
        var i$, to$, results$ = [];
        for (i$ = 0, to$ = n.style.length; i$ < to$; ++i$) {
          i = i$;
          results$.push(i);
        }
        return results$;
      }()).map(function(it){
        return [n.style[it], n.style[n.style[it]]];
      })
      : [];
    attr = n.attributes
      ? (function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = n.attributes).length; i$ < len$; ++i$) {
          v = ref$[i$];
          results$.push([v.nodeName, v.nodeValue]);
        }
        return results$;
      }()).filter(function(it){
        var ref$;
        return !((ref$ = it[0]) === 'style' || ref$ === 'class');
      })
      : [];
    cls = n.classList
      ? (function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = n.classList).length; i$ < len$; ++i$) {
          v = ref$[i$];
          results$.push(v);
        }
        return results$;
      }())
      : [];
    node = {
      type: 'tag',
      name: name,
      style: style,
      attr: attr,
      cls: cls
    };
    if (n.hasAttribute('custom') && n._plugin) {
      ref1$ = (node.type = 'custom', node);
      ref1$.name = (ref$ = n._plugin).name;
      ref1$.version = ref$.version;
      ref1$.data = ref$.data;
      ref1$.plugin = ref$.plugin;
    }
    return node;
  };
  /**
   * serialize a DOM tree.
   * @param {Element} n - DOM tree root node.
   * @return {json} a serialized JSON representing the input DOM.
   */
  serialize = function(n, plugins, win){
    var node, child, i$, to$, i, ret;
    win == null && (win = window);
    node = wrap(n, plugins, win);
    child = [];
    if (!n.childNodes) {
      return;
    }
    for (i$ = 0, to$ = n.childNodes.length; i$ < to$; ++i$) {
      i = i$;
      ret = serialize(n.childNodes[i], plugins, win);
      child.push(ret);
    }
    node.child = child;
    return node;
  };
  /**
   * deserialize a JSON into corresponding DOM tree.
   * @param {json} n - JSON representation of a serialized DOM tree.
   * @param {Function} plugin - optional plugin function to handle custom type DOM Node.
   * @return {Promise} - a promise resolving to an object containing following fields:
   *   - node {Element}: deserialized DOM tree or placeholder div for being replaced by instantiated block.
   *   - promise {Promise}: resolve to all pending block retrieval.
   */
  deserialize = function(n, plugins, win){
    var doc, queue;
    win == null && (win = window);
    doc = win.document;
    queue = [];
    return Promise.resolve().then(function(){
      var _;
      _ = function(n){
        var node, i$, ref$, len$, c, ret, promise, plugs, res$, to$, i, plugin, t;
        switch (n.type) {
        case 'text':
          return doc.createTextNode(n.value);
        case 'comment':
          return doc.createComment(n.value);
        case 'document-fragment':
          node = doc.createDocumentFragment();
          for (i$ = 0, len$ = (ref$ = n.child || []).length; i$ < len$; ++i$) {
            c = ref$[i$];
            if (ret = _(c)) {
              node.appendChild(ret);
            }
          }
          return node;
        case 'tag':
          node = doc.createElement(n.name);
          asc(n, node);
          for (i$ = 0, len$ = (ref$ = n.child || []).length; i$ < len$; ++i$) {
            c = ref$[i$];
            if (ret = _(c)) {
              node.appendChild(ret);
            }
          }
          return node;
        default:
          ref$ = [doc.createElement('div'), null], node = ref$[0], promise = ref$[1];
          for (i$ = 0, len$ = (ref$ = n.child || []).length; i$ < len$; ++i$) {
            c = ref$[i$];
            if (ret = _(c)) {
              node.appendChild(ret);
            }
          }
          res$ = [];
          for (i$ = 0, len$ = (ref$ = n.plug || []).length; i$ < len$; ++i$) {
            c = ref$[i$];
            res$.push(_(c));
          }
          plugs = res$;
          for (i$ = 0, to$ = plugins.length; i$ < to$; ++i$) {
            i = i$;
            if (!plugins[i].test({
              data: n
            })) {
              continue;
            }
            plugin = plugins[i];
            break;
          }
          if (!plugin) {
            node.appendChild(doc.createTextNode("(unknown)"));
            return node;
          }
          ret = plugin.serialize({
            data: n,
            node: node,
            window: win
          });
          if (!ret) {
            node.appendChild(doc.createTextNode("(unknown)"));
          } else if (ret instanceof Promise) {
            node.appendChild(t = doc.createTextNode("(.. loading ..)"));
            promise = ret.then(function(newNode){
              if (t.parentNode) {
                t.parentNode.removeChild(t);
              }
              if (node !== newNode) {
                node.replaceWith(newNode);
              }
              newNode.setAttribute('dd-plugin', plugin.id);
              asc(n, newNode);
              return newNode;
            });
          } else if (ret instanceof win.Element) {
            node = ret;
          } else {
            node = ret.node, promise = ret.promise;
          }
          if (promise) {
            queue.push(promise);
          }
          node.setAttribute('dd-plugin', plugin.id);
          asc(n, node);
          return node;
        }
      };
      return _(n);
    }).then(function(node){
      return {
        node: node,
        promise: Promise.all(queue)
      };
    });
  };
  /**
   * apply op based on a data / root pair.
   * @param {json} op - operational transformation
   * @param {json} data - serialized DOM tree
   * @param {Element} root - root of the corresponding DOM tree
   */
  locate = function(op, data, root){
    var n, obj, dd, i$, i, ref$, to$, j, p;
    n = obj = root;
    dd = data;
    for (i$ = op.p.length - 1; i$ >= 0; --i$) {
      i = i$;
      if ((ref$ = op.p[i]) === 'attr' || ref$ === 'style' || ref$ === 'cls' || ref$ === 'child' || ref$ === 'name' || ref$ === 'value' || ref$ === 'type') {
        break;
      }
    }
    for (i$ = 0, to$ = i - 1; i$ < to$; ++i$) {
      j = i$;
      p = op.p[i];
      obj = p === 'child' ? obj.childNodes : obj;
      dd = dd[p];
    }
    switch (op.p[i]) {
    case 'name':
    case 'value':
    case 'type':
      return deserialize(dd).then(function(arg$){
        var node, promise;
        node = arg$.node, promise = arg$.promise;
        obj.parentNode.insertBefore(node, obj);
        return obj.parentNode.removeChild(obj);
      });
    case 'style':
      obj.setAttribute('style', '');
      return dd.style.map(function(it){
        return obj.style[it[0]] = it[1];
      });
    case 'cls':
      return obj.setAttribute('class', dd.cls.join(' '));
    case 'attr':
      Array.from(obj.attributes).map(function(it){
        var ref$;
        if (!dd.attr[it.name] && !((ref$ = it.name) === 'custom' || ref$ === 'style' || ref$ === 'class')) {
          return obj.removeAttribute(it.name);
        }
      });
      return dd.attr.map(function(it){
        return obj.setAttribute(it[0], it[1]);
      });
    case 'child':
      if (op.ld) {
        obj.removeChild(obj.childNodes[op.p[i + 1]]);
      }
      if (op.li) {
        return deserialize(op.li).then(function(arg$){
          var node, promise;
          node = arg$.node, promise = arg$.promise;
          return obj.insertBefore(node, obj.childNodes[op.p[i + 1]]);
        });
      }
    }
  };
  main = function(opt){
    var that;
    opt == null && (opt = {});
    this.opt = opt;
    this.window = (that = opt.window)
      ? that
      : typeof window != 'undefined' && window !== null ? window : null;
    this.plugins = (that = Array.isArray(opt.plugin))
      ? that
      : opt.plugin
        ? [opt.plugin]
        : [];
    if (opt.data) {
      this.data = opt.data;
    } else if (opt.node) {
      this.node = opt.node;
    }
    return this;
  };
  main.prototype = import$(Object.create(Object.prototype), {
    init: function(){
      var this$ = this;
      if (this.node) {
        return Promise.resolve().then(function(){
          return this$.data = serialize(this$.node, this$.plugins, this$.window);
        });
      } else {
        return deserialize(this.data, this.plugins, this.window).then(function(arg$){
          var node, promise;
          node = arg$.node, promise = arg$.promise;
          this$.node = node;
          return {
            node: node,
            promise: promise
          };
        });
      }
    },
    getData: function(){
      return this.data;
    },
    getNode: function(){
      return this.node;
    },
    update: function(ops){
      var i$, len$, op, results$ = [];
      ops == null && (ops = []);
      for (i$ = 0, len$ = ops.length; i$ < len$; ++i$) {
        op = ops[i$];
        json0.type.apply(this.data, [op]);
        results$.push(locate(op, this.data, this.node));
      }
      return results$;
    }
  });
  main.serialize = serialize;
  main.deserialize = deserialize;
  if (typeof module != 'undefined' && module !== null) {
    module.exports = main;
  }
  if (typeof window != 'undefined' && window !== null) {
    window.datadom = main;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
